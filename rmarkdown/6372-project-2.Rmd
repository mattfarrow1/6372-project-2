---
title: '6372: Project 2'
author: "Edward, Matt, Michael"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)  # general data processing & plotting
library(here)       # relative location references
library(janitor)    # data cleanup tools
library(naniar)     # dealing with missing values
library(caret)      # misc functions for training and plotting classification and regression models
library(tidymodels)
library(GGally)
```

# Load Data

```{r}
# Read data
bank <- read_delim(here("data - raw", "bank-additional", "bank-additional-full.csv"), 
                   ";", escape_double = FALSE, trim_ws = TRUE)

# Clean column names
bank <- clean_names(bank)
```

## Attribute Information ([source](https://archive.ics.uci.edu/ml/datasets/Bank%20Marketing))

### Bank Client Data

1.    **age**
2.    **job**: type of job
3.    **marital**: marital status
4.    **education**
5.    **default**: has credit in default? 
6.    **housing**: has housing loan?
7.    **loan**: has personal loan?

### Related with the Last Contact of the Current Campaign

8.    **contact**: contact communication type
9.    **month**: last contact month of year 
10.   **day_of_week**: last contact day of the week
11.   **duration**: last contact duration, in seconds. Important note: this attribute highly affects the output target (e.g., if duration=0 then y='no'). Yet, the duration is not known before a call is performed. Also, after the end of the call y is obviously known. Thus, this input should only be included for benchmark purposes and should be discarded if the intention is to have a realistic predictive model.

### Other Attributes

12.   **campaign**: number of contacts performed during this campaign and for this client (includes last contact)
13.   **pdays**: number of days that passed by after the client was last contacted from a previous campaign (999 means client was not previously contacted)
14.   **previous**: number of contacts performed before this campaign and for this client
15.   **poutcome**: outcome of the previous marketing campaign

### Social and Economic Context Attributes

16.   **emp.var.rate**: employment variation rate - quarterly indicator
17.   **cons.price.idx**: consumer price index - monthly indicator
18.   **cons.conf.idx**: consumer confidence index - monthly indicator
19.   **euribor3m**: euribor 3 month rate - daily indicator
20.   **nr.employed**: number of employees - quarterly indicator

### Output Variable (Desired Target)
21.   **y**: has the client subscribed to a term deposit?

# Initial Data Examination

```{r}
# What are the dimensions of the data
dim(bank)

# Look at the first and last rows of data
head(bank)
tail(bank)
glimpse(bank)

# Summary statistics
summary(bank)
skimr::skim(bank)

# Other possible functions for examining the data that may be helpful
Hmisc::describe(bank)
psych::describe(bank)
# DataExplorer::create_report(bank)
```

# Data Cleanup

```{r}
# Missing Values

# Several things happening here:
#     - Convert "unknown" to NA
#     - 999 means client was not previously contacted
#     - poutcome has a value "nonexistent" that is essentially missing 
#       since the prospect was not contacted
bank_clean <- bank %>% 
  replace_with_na_all(condition = ~ .x == "unknown") %>% 
  replace_with_na(replace = list(pdays = 999)) %>% 
  replace_with_na(replace = list(poutcome = "nonexistent"))

# Count number of missing values in data set
colSums(is.na(bank_clean))

# Re-level factors
bank_clean <- bank_clean %>% 
  mutate(day_of_week = ordered(bank$day_of_week, levels = c("mon", "tue", "wed", "thu", "fri")),
         month = ordered(bank$month, levels = c("mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec")))

# Rename response variable
bank_clean <- bank_clean %>% 
  rename(subscribed = y)

bank_clean %>% 
  # Are there any housing or personal loans?
  mutate(any_loan = (housing == "yes" | loan == "yes")) %>% 
  # Based on the EDA, it doesn't appear as though day of the week is necessarily
  # notable, but I'll make a factor just in case
  mutate(weekdays_3 = if_else(day_of_week == "mon", "Beginning",
                              if_else(day_of_week == "fri", "End", "Middle")))


# Convert character variables to factors
bank_clean <- bank_clean %>%
  mutate(across(where(is_character), as_factor))
```

# Post-Cleanup Examination

```{r}
# Re-run reports
DataExplorer::create_report(bank_clean)
Hmisc::describe(bank_clean)
psych::describe(bank_clean)
skimr::skim(bank_clean)

# Reports from inspectdf (categorical variables and Pearson correlation
# coefficients)
inspectdf::inspect_cat(bank_clean)
inspectdf::inspect_cor(bank_clean)
```

# Exploratory Data Analysis

## Check for Correlation

```{r correlation, message=FALSE, warning=FALSE, echo=FALSE}
# Run correlations and save output as images to be used in the appendix.
ggcorr(
  bank_clean,
  label = TRUE,
  label_alpha = TRUE,
  label_size = 3,
  layout.exp = 2,
  cex = 3.5,
  hjust = 1
)

# ggsave(here::here("images", "correlation 1.png"))
```

```{r message=FALSE, warning=FALSE}
# Examine the numeric data points
numericals <- seq(1, length(bank_clean))[unlist(lapply(bank_clean, is.numeric))]

# Correlation plot for numeric data points
library(corrplot)
source("http://www.sthda.com/upload/rquery_cormat.r")
rquery.cormat(bank_clean[sapply(bank_clean, is.numeric)])

# Scatter plot matrix
ggpairs(bank_clean, columns = numericals, ggplot2::aes(colour = subscribed))

# Box plots of numeric variables
bank_clean %>% 
  select(age, duration, campaign, pdays, previous, emp_var_rate, cons_conf_idx, cons_price_idx, nr_employed, subscribed) %>%
  pivot_longer(., cols = -subscribed, names_to = "Var", values_to = "Val") %>% 
  ggplot(aes(Var, Val, fill = subscribed)) +
  geom_boxplot() +
  facet_wrap(~ Var, scales = "free") +
  labs(title = "Exploratory Data Analysis of Numeric Variables") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

# Models

```{r}
library(caTools)
set.seed(123)
split <- sample.split(bank_clean$subscribed, SplitRatio = 0.60)
train_data <- subset(bank_clean, split == TRUE)
test_data <- subset(bank_clean, split == FALSE)

# Logistic regression model 1
model1 <-
  glm(
    subscribed ~ month + day_of_week + campaign + emp_var_rate + contact + poutcome + cons_conf_idx,
    data = train_data,
    family = binomial
  )

# Get summary of model1
summary(model1)

predict_test <- predict(model1, type = "response", newdata = test_data)
summary(predict_test)
table(test_data$subscribed, predict_test > 0.20) # return confusion matrix. repeat for various threshold values

library(ROCR)
# Use this code chunk to find ROC curve and calculate AUC
# ROCRpred <- prediction(predict_test, test_data$subscribed)
# as.numeric(performance(ROCRpred, "auc")@y.values)
# ROCRperf <- performance(ROCRpred, "tpr", "fpr")
# plot(ROCRperf, colorize = TRUE, print.cutoffs.at = seq(0, 1, 0.005), text.adj = c(-0.2, 1.7))

# Build and analyze regression tree
library(rpart)
library(rpart.plot)
cart1 <-
  rpart(
    subscribed ~ job + default + education + housing + loan + contact + poutcome,
    data = train_data,
    control = rpart.control(
      minsplit = 1,
      minbucket = 20,
      cp = 0.001
    )
  )

prediction_cart <- predict(cart1, newdata = test_data)
# table(test_data$subscribed, prediction_cart > 0.20) # return confusion matrix. repeat for various threshold values
summary(cart1)
prp(cart1)
```

# Appendix

## R Code {-}

```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}

```