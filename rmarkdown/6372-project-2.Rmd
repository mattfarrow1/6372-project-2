---
title: '6372: Project 2'
author: "Edward, Matt, Michael"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
```

```{r library-setup}
library(tidyverse)  # general data processing & plotting
library(here)       # relative location references
library(janitor)    # data cleanup tools
library(naniar)     # dealing with missing values
library(caret)      # misc functions for training and plotting classification and regression models
library(tidymodels)
library(GGally)     # for ggpairs
library(MASS)       # for LDA/QDA
```

# Load Data

```{r load-data}
# Read data
bank <- read_delim(here("data - raw", "bank-additional", "bank-additional-full.csv"), 
                   ";", escape_double = FALSE, trim_ws = TRUE)

# Clean column names
bank <- clean_names(bank)

# Quick examination of the data
glimpse(bank)
head(bank)
```

## Attribute Information ([source](https://archive.ics.uci.edu/ml/datasets/Bank%20Marketing))

### Bank Client Data

1.    **age**
2.    **job**: type of job
3.    **marital**: marital status
4.    **education**
5.    **default**: has credit in default? 
6.    **housing**: has housing loan?
7.    **loan**: has personal loan?

### Related with the Last Contact of the Current Campaign

8.    **contact**: contact communication type
9.    **month**: last contact month of year 
10.   **day_of_week**: last contact day of the week
11.   **duration**: last contact duration, in seconds. Important note: this attribute highly affects the output target (e.g., if duration=0 then y='no'). Yet, the duration is not known before a call is performed. Also, after the end of the call y is obviously known. Thus, this input should only be included for benchmark purposes and should be discarded if the intention is to have a realistic predictive model.

### Other Attributes

12.   **campaign**: number of contacts performed during this campaign and for this client (includes last contact)
13.   **pdays**: number of days that passed by after the client was last contacted from a previous campaign (999 means client was not previously contacted)
14.   **previous**: number of contacts performed before this campaign and for this client
15.   **poutcome**: outcome of the previous marketing campaign

### Social and Economic Context Attributes

16.   **emp.var.rate**: employment variation rate - quarterly indicator
17.   **cons.price.idx**: consumer price index - monthly indicator
18.   **cons.conf.idx**: consumer confidence index - monthly indicator
19.   **euribor3m**: euribor 3 month rate - daily indicator
20.   **nr.employed**: number of employees - quarterly indicator

### Output Variable (Desired Target)
21.   **y**: has the client subscribed to a term deposit?

# Data Cleanup

```{r data-cleanup}
# Address missing Values
#     - Convert "unknown" to NA
#     - 999 means client was not previously contacted
#     - poutcome has a value "nonexistent" that is essentially missing 
#       since the prospect was not contacted
bank_clean <- bank %>% 
  replace_with_na_all(condition = ~ .x == "unknown") %>% 
  replace_with_na(replace = list(pdays = 999)) %>% 
  replace_with_na(replace = list(poutcome = "nonexistent"))

# Re-level factors
bank_clean <- bank_clean %>% 
  mutate(day_of_week = ordered(bank$day_of_week, levels = c("mon", "tue", "wed", "thu", "fri")),
         month = ordered(bank$month, levels = c("mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec")))

# Rename response variable
bank_clean <- bank_clean %>% 
  rename(subscribed = y)

# Feature engineering
bank_clean <- bank_clean %>% 
  # Are there any housing or personal loans?
  mutate(any_loan = (housing == "yes" | loan == "yes")) %>% 
  # Based on the EDA, it doesn't appear as though day of the week is necessarily
  # notable, but I'll make a factor just in case
  mutate(weekdays_3 = if_else(day_of_week == "mon", "Beginning",
                              if_else(day_of_week == "fri", "End", "Middle")))

# Convert character variables to factors
bank_clean <- bank_clean %>%
  mutate(across(where(is_character), as_factor))

# In exploring and considering the data, knowing the duration of the call is an
# unknowable predictor going into a call. Therefore, we made the decision to
# remove it from the data set.
bank_clean <- bank_clean %>% 
  dplyr::select(-duration)
```

# Post-Cleanup Examination

```{r}
# Re-run reports
DataExplorer::create_report(bank_clean)
Hmisc::describe(bank_clean)
psych::describe(bank_clean)
skimr::skim(bank_clean)

# Reports from inspectdf (categorical variables and Pearson correlation
# coefficients)
bank_cat  <- inspectdf::inspect_cat(bank_clean)
bank_pear <- inspectdf::inspect_cor(bank_clean)

# Remove highly correlated variables
bank_clean <- bank_clean %>% 
  dplyr::select(-c(nr_employed))

# Reexamine Pearson correlation coefficients
bank_pear2 <- inspectdf::inspect_cor(bank_clean)

# Visual check of correlations and save output as an image to be used in the
# appendix
ggcorr(
  bank_clean,
  label = TRUE,
  label_alpha = TRUE,
  label_size = 3,
  layout.exp = 2,
  cex = 3.5,
  hjust = 1
)

ggsave(here::here("images", "correlation 1.png"))
```

# Exploratory Data Analysis

## Examine Continuous Variables

```{r message=FALSE, warning=FALSE}
# Get indices of continuous variables
numeric_cols <- seq(1, length(bank_clean))[unlist(lapply(bank_clean, is.numeric))]

# Scatter plot matrix
ggpairs(bank_clean, columns = numeric_cols, ggplot2::aes(colour = subscribed))

ggsave(here::here("images", "correlation 2.png"))

# Box plots of numeric variables
bank_clean %>% 
  dplyr::select(age, campaign, pdays, previous, cons_conf_idx, cons_price_idx, subscribed) %>%
  pivot_longer(., cols = -subscribed, names_to = "Var", values_to = "Val") %>% 
  ggplot(aes(Var, Val, fill = subscribed)) +
  geom_boxplot() +
  facet_wrap(~ Var, scales = "free") +
  labs(title = "Exploratory Data Analysis of Numeric Variables") +
  theme_minimal() +
  theme(legend.position = "bottom")

ggsave(here::here("images", "numeric variables.png"))


# Stacked bar plots of categorical variables
bank_clean %>% 
  dplyr::select(job, marital, education, default, housing, loan, contact, poutcome, weekdays_3, subscribed) %>% 
  pivot_longer(., cols = -subscribed, names_to = "Var", values_to = "Val") %>% 
  group_by(subscribed, Var) %>% 
  count(Val) %>% 
  filter(!is.na(Val)) %>% 
  ggplot(aes(Val, n, fill = subscribed)) +
  geom_col() +
  facet_wrap(~ Var, scales = "free") +
  coord_flip() +
  labs(title = "Exploratory Data Analysis of Categorical Variables") +
  theme_minimal() +
  theme(legend.position = "bottom")

ggsave(here::here("images", "categorical variables.png"))
```

# Models

```{r}
library(caTools)
set.seed(123)
split <- sample.split(bank_clean$subscribed, SplitRatio = 0.60)
train_data <- subset(bank_clean, split == TRUE)
test_data <- subset(bank_clean, split == FALSE)

# Logistic regression model 1
model1 <-
  glm(
    subscribed ~ month + day_of_week + campaign + emp_var_rate + contact + poutcome + cons_conf_idx,
    data = train_data,
    family = binomial
  )

# Get summary of model1
summary(model1)

predict_test <- predict(model1, type = "response", newdata = test_data)
summary(predict_test)
table(test_data$subscribed, predict_test > 0.20) # return confusion matrix. repeat for various threshold values

library(ROCR)
# Use this code chunk to find ROC curve and calculate AUC
# ROCRpred <- prediction(predict_test, test_data$subscribed)
# as.numeric(performance(ROCRpred, "auc")@y.values)
# ROCRperf <- performance(ROCRpred, "tpr", "fpr")
# plot(ROCRperf, colorize = TRUE, print.cutoffs.at = seq(0, 1, 0.005), text.adj = c(-0.2, 1.7))

# Build and analyze regression tree
library(rpart)
library(rpart.plot)
cart1 <-
  rpart(
    subscribed ~ job + default + education + housing + loan + contact + poutcome,
    data = train_data,
    control = rpart.control(
      minsplit = 1,
      minbucket = 20,
      cp = 0.001
    )
  )

prediction_cart <- predict(cart1, newdata = test_data)
# table(test_data$subscribed, prediction_cart > 0.20) # return confusion matrix. repeat for various threshold values
summary(cart1)
prp(cart1)
```

# LDA/QDA Model

## Prep Data

```{r lda}
set.seed(123)

# Create LDA data set.
lda_data <- bank_clean %>% 
  dplyr::select(c("subscribed",
                  "cons_price_idx",
                  "cons_conf_idx",
                  "euribor3m"))

# Examine the data
skimr::skim(lda_data)

# Check number of yes/no responses
lda_data %>% 
  count(subscribed)

# Down-sample the data to get an equal number of yes and no responses
lda_ds <- downSample(x = lda_data[, 2:4],
                            y = lda_data$subscribed)

# Double-check the number of yes/no responses
lda_ds %>% 
  count(Class)

# Build test/train data sets
lda_indices <- sample(nrow(lda_ds), size = floor(0.75 * nrow(lda_ds)))
lda_train   <- as_tibble(lda_ds[lda_indices, ])
lda_test    <- as_tibble(lda_ds[-lda_indices, ])
```

## LDA using MASS

```{r}
# Run LDA
bank_lda <- lda(Class ~ cons_price_idx + cons_conf_idx + euribor3m, data = lda_train)

# Make predictions
bank_lda_predict <- predict(bank_lda, newdata = lda_test)$class

# Define truth
bank_lda_truth <- lda_test$Class

# Generate confusion matrix
confusionMatrix(bank_lda_predict,
                bank_lda_truth)
```

## LDA using Caret

```{r}
# Define control parameters for train
lda_control <- trainControl(
  method = "cv",
  number = 10,
  savePredictions = T,
  summaryFunction = twoClassSummary,
  classProbs = T,
)

# LDA using Caret
bank_lda <-
  train(
    Class ~ cons_price_idx + cons_conf_idx + euribor3m,
    data = lda_train,
    method = "lda",
    trControl = lda_control
  )

# Make predictions
bank_lda_predict <- predict(bank_lda, newdata = lda_test)

# Define truth
bank_lda_truth <- lda_test$Class

# Generate confusion matrix
confusionMatrix(bank_lda_predict,
                bank_lda_truth)
```

## QDA

```{r qda}
# QDA
bank_qda <- qda(Class ~ cons_price_idx + cons_conf_idx + euribor3m, data = lda_train)

# Make predictions
bank_qda_predict <- predict(bank_qda, newdata = lda_test)$class

# Define truth
bank_qda_truth <- lda_test$Class

# Generate confusion matrix
confusionMatrix(bank_qda_predict,
                bank_qda_truth)
```

# Appendix

## R Code {-}

```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}

```